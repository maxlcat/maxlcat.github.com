{"pages":[],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/05/13/hello-world/"},{"title":"JavaConfig学习","text":"Spring JavaConfig Reference Guide 该文档所引入的包 spring-javaconfig 在Spring3.0之后不再使用，JavaConfig作为Spring核心的功能，JavaConfigApplicationContext 被替换为AnnotationConfigApplicationContet.目前在项目中用到的xml与JavaConfig结合的方式使用,将数据库连接、路径扫描配置在XML中，有些bean通过@Bean进行将其放入到容器中。 @Configuration @Bean@Configuration 相当于XML中 &lt;beans/&gt;元素，@Bean相当于XML中的&lt;bean/&gt; 12345678910@Configurationpublic class AppConfig { @Autowired //直接引用其他的bean DateSource dataSource; @Bean public Animal animal() { return new Animal(); }}相当于xml：bean.xml 1234567&lt;beans xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.springframework.org/schema/beans&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; &lt;bean id=&quot;animal&quot; class=&quot;com.maxlcat.bean.Animal&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;启动 12ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);System.out.println(context.getBean(&quot;animal&quot;));@Import、@ImportResource 12@Import(DataConfig.class)@ImportResource(&quot;classpath:dataConfig.xml&quot;)@ImportResource相当于xml文件中的 1&lt;import resource=&quot;dataConfig.xml&quot; /&gt;@ComponentScan 相当于xml文件中 1&lt;context:component-scan&gt; @PropertySource 读取配置文件的信息 1234567891011@Configuration@PropertySource(&quot;bean.properties&quot;)public class AppConfig { @Autowired Environment env; @Bean public Animal animal() { return new Animal(env.getProperty(&quot;name&quot;)); }} 参考：Spring JavaConfig Reference Guidehttp://stackoverflow.com/questions/7295642/spring-javaconfig-nosuchbeandefinitionexception-no-unique-bean-of-type/7295738#7295738","link":"/2017/05/14/JavaConfig%E5%AD%A6%E4%B9%A0/"},{"title":"Docker命令","text":"镜像设置镜像下载地址 Mac 1Preferences-&gt;Daemon-&gt;Registry mirrors-&gt; add http://aad0405c.m.daocloud.io查询远程Mysql镜像 1docker search mysql 获取mysql 镜像 1docker pull mysql查看本地镜像 1docker images删除镜像，按标签删除 1docker rmi mysql:latest 容器创建并启动容器 1docker run --name mysql-server -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql 查看容器信息 12345docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 8d57152e926c mysql &quot;docker-entrypoint...&quot; 2 hours ago Exited (0) 13 seconds ago mysql-server 422a14b34375 hello-world &quot;/hello&quot; 3 days ago Exited (0) 3 days ago dreamy_chandrasekhar 终止容器 1docker stop 8d57152e926c","link":"/2017/07/24/Docker%E5%91%BD%E4%BB%A4/"},{"title":"UML类图及关系","text":"UML类图定义一个User类 1234567891011public class User { private String name; private int age; private int sex; public void save() { .... }}其对应的UML图为 UML类图一般由三个部分组成 类的名称 类的属性（Attributes），UML属性的表示方式为： 可见性 名称:类型[=缺省值] 可见性：private、protected、public 分别用符号”-“、”#”、”+” 表示 名称：属性名 类型 缺省值：可选，属性初始值 类的操作（Operations）,表示方式：可见性 名称(参数列表)[:返回类型] 类与类的关系 依赖元素A的变化会影响到B，反之不成立，那么B依赖A。依赖用虚线箭头表示 123456789public class Driver { public void driver(Car car) { ... }}public class Car { ...} 关联是一种结构化关系，表示两个类之间存在关系，如学生和学校就是一种关联关系。关联关系用实线表示，箭头指向被关联的类，关联可以是双向的，用直线表示 12345public class Student { private School school; ...} 聚合聚合也属于关联，表示部分与整体的关系，部分可以独立存在。用空心菱形表示，菱形指向整体。 12345678public class Car { private Engine engine; }public class Engine {} 组合组合也表示部分与整体，但是整体不存在了，部分也不存在。用实心菱形表示，菱形指向整体 12345678910public class Person { private Foot foot; public Person() { foot = new Foot(); }}public class Foot{} 泛化表示继承关系，用空心箭头实线表示，箭头指向父类 实现实现接口，用空心箭头虚线表示，箭头指向接口 引用深入浅出UML类图看懂UML类图和时序图UML类图符号 各种关系说明以及举例","link":"/2017/12/12/UML%E7%B1%BB%E5%9B%BE%E5%8F%8A%E5%85%B3%E7%B3%BB/"},{"title":"单例模式","text":"单例模式，每次获取的对象都是同一个，外部实例化只能通过调用方法，构造函数设置为私有，无法通过new实例，适用于需要频繁实例化或者实例化时消耗太多资源。实现方式有三种：饿汉模式、懒汉模式、IoDH模式 – 饿汉模式饿汉，从字面意思上理解就是急切需要实例对象，在类加载时就创建了对象，启东时时间会长一些1234567public class Singleton { private static Singleton instance = new Singleton(); private Singleton { } public static Singleton instance() { return instance; }} 懒汉模式懒汉,当第一次调用时实例化，类加载时不进行实例化12345678910public class Singleton { private static Singleton instance = null; privagte Singleton() { } public static Singleton getInstance() { if(instance == null) { instance = new Singleton(); } return instance; }} 上面是一个简单的懒汉模式的实现，但是存在线程安全的问题，会造成创建多个对象的情况，下面通过双重校验实现一个线程安全的懒汉模式 1234567891011121314public class Singleton { private static volatile Singleton instance = null; private Singleton() {} public static Singleton getInstance() { if(instance == null) { synchronized (Singleton.class) { if(instance == null){ instance = new Singleton(); } } } return instance; }} IoDH模式123456789public class Singleton { private Singleton() {} private static class HolderClass { private final static Singleton instance = new Singleton(); } public static Singleton getInstance(){ return HolderClass.instance; }} 该模式利用Java虚拟机来实现线程安全，类加载时也不会创建实例 参考：https://gof.quanke.name","link":"/2017/04/17/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"},{"title":"设计模式","text":"面向对象设计原则 单一职责原则 开闭原则 对扩展开放，对修改关闭 里氏代换 将父类对象替换成子类对象，程序不会产生任何异常 依赖倒转原则 核心是面向接口编程，尽量每个实现类都依赖于接口或抽象类，而不是了依赖于具体的实现 High level modules should not depend upon low level modules. Both should depend upon abstractions. Abstractions should not depend upon details. Details should depend upon abstractions.高层模块不能依赖低层模块，两者应该依赖其抽象; 抽象不应该依赖细节; 细节应该依赖抽象. 接口隔离原则 客户端不依赖不需要的接口 合成复用原则 主要的尽量实现对扩展开放、对修改关闭 参考：https://gof.quanke.name","link":"/2017/04/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"docker","slug":"docker","link":"/tags/docker/"}],"categories":[]}